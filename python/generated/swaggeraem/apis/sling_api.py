# coding: utf-8

"""
    Adobe Experience Manager (AEM) API

    Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API

    OpenAPI spec version: 2.2.0
    Contact: opensource@shinesolutions.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..api_client import ApiClient


class SlingApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_agent(self, runmode, name, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_agent(runmode, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_agent_with_http_info(runmode, name, **kwargs)
        else:
            (data) = self.delete_agent_with_http_info(runmode, name, **kwargs)
            return data

    def delete_agent_with_http_info(self, runmode, name, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_agent_with_http_info(runmode, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runmode', 'name']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_agent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in params) or (params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `delete_agent`")
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_agent`")


        collection_formats = {}

        path_params = {}
        if 'runmode' in params:
            path_params['runmode'] = params['runmode']
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/etc/replication/agents.{runmode}/{name}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_node(self, path, name, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_node(path, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_node_with_http_info(path, name, **kwargs)
        else:
            (data) = self.delete_node_with_http_info(path, name, **kwargs)
            return data

    def delete_node_with_http_info(self, path, name, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_node_with_http_info(path, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'name']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `delete_node`")
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_node`")


        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/{path}/{name}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_agent(self, runmode, name, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_agent(runmode, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_agent_with_http_info(runmode, name, **kwargs)
        else:
            (data) = self.get_agent_with_http_info(runmode, name, **kwargs)
            return data

    def get_agent_with_http_info(self, runmode, name, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_agent_with_http_info(runmode, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runmode', 'name']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in params) or (params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `get_agent`")
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_agent`")


        collection_formats = {}

        path_params = {}
        if 'runmode' in params:
            path_params['runmode'] = params['runmode']
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/etc/replication/agents.{runmode}/{name}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_agents(self, runmode, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_agents(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_agents_with_http_info(runmode, **kwargs)
        else:
            (data) = self.get_agents_with_http_info(runmode, **kwargs)
            return data

    def get_agents_with_http_info(self, runmode, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_agents_with_http_info(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runmode']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in params) or (params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `get_agents`")


        collection_formats = {}

        path_params = {}
        if 'runmode' in params:
            path_params['runmode'] = params['runmode']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/etc/replication/agents.{runmode}.-1.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_authorizable_keystore(self, intermediate_path, authorizable_id, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_authorizable_keystore(intermediate_path, authorizable_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str intermediate_path: (required)
        :param str authorizable_id: (required)
        :return: KeystoreInformations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_authorizable_keystore_with_http_info(intermediate_path, authorizable_id, **kwargs)
        else:
            (data) = self.get_authorizable_keystore_with_http_info(intermediate_path, authorizable_id, **kwargs)
            return data

    def get_authorizable_keystore_with_http_info(self, intermediate_path, authorizable_id, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_authorizable_keystore_with_http_info(intermediate_path, authorizable_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str intermediate_path: (required)
        :param str authorizable_id: (required)
        :return: KeystoreInformations
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['intermediate_path', 'authorizable_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_authorizable_keystore" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'intermediate_path' is set
        if ('intermediate_path' not in params) or (params['intermediate_path'] is None):
            raise ValueError("Missing the required parameter `intermediate_path` when calling `get_authorizable_keystore`")
        # verify the required parameter 'authorizable_id' is set
        if ('authorizable_id' not in params) or (params['authorizable_id'] is None):
            raise ValueError("Missing the required parameter `authorizable_id` when calling `get_authorizable_keystore`")


        collection_formats = {}

        path_params = {}
        if 'intermediate_path' in params:
            path_params['intermediatePath'] = params['intermediate_path']
        if 'authorizable_id' in params:
            path_params['authorizableId'] = params['authorizable_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/{intermediatePath}/{authorizableId}.ks.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KeystoreInformations',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_keystore(self, intermediate_path, authorizable_id, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_keystore(intermediate_path, authorizable_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str intermediate_path: (required)
        :param str authorizable_id: (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_keystore_with_http_info(intermediate_path, authorizable_id, **kwargs)
        else:
            (data) = self.get_keystore_with_http_info(intermediate_path, authorizable_id, **kwargs)
            return data

    def get_keystore_with_http_info(self, intermediate_path, authorizable_id, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_keystore_with_http_info(intermediate_path, authorizable_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str intermediate_path: (required)
        :param str authorizable_id: (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['intermediate_path', 'authorizable_id']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_keystore" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'intermediate_path' is set
        if ('intermediate_path' not in params) or (params['intermediate_path'] is None):
            raise ValueError("Missing the required parameter `intermediate_path` when calling `get_keystore`")
        # verify the required parameter 'authorizable_id' is set
        if ('authorizable_id' not in params) or (params['authorizable_id'] is None):
            raise ValueError("Missing the required parameter `authorizable_id` when calling `get_keystore`")


        collection_formats = {}

        path_params = {}
        if 'intermediate_path' in params:
            path_params['intermediatePath'] = params['intermediate_path']
        if 'authorizable_id' in params:
            path_params['authorizableId'] = params['authorizable_id']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/octet-stream'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/{intermediatePath}/{authorizableId}/keystore/store.p12', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_node(self, path, name, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_node(path, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_node_with_http_info(path, name, **kwargs)
        else:
            (data) = self.get_node_with_http_info(path, name, **kwargs)
            return data

    def get_node_with_http_info(self, path, name, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_node_with_http_info(path, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'name']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_node`")
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_node`")


        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/{path}/{name}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_package(self, group, name, version, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_package(group, name, version, async=True)
        >>> result = thread.get()

        :param async bool
        :param str group: (required)
        :param str name: (required)
        :param str version: (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_package_with_http_info(group, name, version, **kwargs)
        else:
            (data) = self.get_package_with_http_info(group, name, version, **kwargs)
            return data

    def get_package_with_http_info(self, group, name, version, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_package_with_http_info(group, name, version, async=True)
        >>> result = thread.get()

        :param async bool
        :param str group: (required)
        :param str name: (required)
        :param str version: (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group', 'name', 'version']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_package" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group' is set
        if ('group' not in params) or (params['group'] is None):
            raise ValueError("Missing the required parameter `group` when calling `get_package`")
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_package`")
        # verify the required parameter 'version' is set
        if ('version' not in params) or (params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `get_package`")


        collection_formats = {}

        path_params = {}
        if 'group' in params:
            path_params['group'] = params['group']
        if 'name' in params:
            path_params['name'] = params['name']
        if 'version' in params:
            path_params['version'] = params['version']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/octet-stream'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/etc/packages/{group}/{name}-{version}.zip', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_package_filter(self, group, name, version, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_package_filter(group, name, version, async=True)
        >>> result = thread.get()

        :param async bool
        :param str group: (required)
        :param str name: (required)
        :param str version: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_package_filter_with_http_info(group, name, version, **kwargs)
        else:
            (data) = self.get_package_filter_with_http_info(group, name, version, **kwargs)
            return data

    def get_package_filter_with_http_info(self, group, name, version, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_package_filter_with_http_info(group, name, version, async=True)
        >>> result = thread.get()

        :param async bool
        :param str group: (required)
        :param str name: (required)
        :param str version: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group', 'name', 'version']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_package_filter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group' is set
        if ('group' not in params) or (params['group'] is None):
            raise ValueError("Missing the required parameter `group` when calling `get_package_filter`")
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_package_filter`")
        # verify the required parameter 'version' is set
        if ('version' not in params) or (params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `get_package_filter`")


        collection_formats = {}

        path_params = {}
        if 'group' in params:
            path_params['group'] = params['group']
        if 'name' in params:
            path_params['name'] = params['name']
        if 'version' in params:
            path_params['version'] = params['version']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_query(self, path, p_limit, _1_property, _1_property_value, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_query(path, p_limit, _1_property, _1_property_value, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param float p_limit: (required)
        :param str _1_property: (required)
        :param str _1_property_value: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_query_with_http_info(path, p_limit, _1_property, _1_property_value, **kwargs)
        else:
            (data) = self.get_query_with_http_info(path, p_limit, _1_property, _1_property_value, **kwargs)
            return data

    def get_query_with_http_info(self, path, p_limit, _1_property, _1_property_value, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_query_with_http_info(path, p_limit, _1_property, _1_property_value, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param float p_limit: (required)
        :param str _1_property: (required)
        :param str _1_property_value: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'p_limit', '_1_property', '_1_property_value']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_query" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_query`")
        # verify the required parameter 'p_limit' is set
        if ('p_limit' not in params) or (params['p_limit'] is None):
            raise ValueError("Missing the required parameter `p_limit` when calling `get_query`")
        # verify the required parameter '_1_property' is set
        if ('_1_property' not in params) or (params['_1_property'] is None):
            raise ValueError("Missing the required parameter `_1_property` when calling `get_query`")
        # verify the required parameter '_1_property_value' is set
        if ('_1_property_value' not in params) or (params['_1_property_value'] is None):
            raise ValueError("Missing the required parameter `_1_property_value` when calling `get_query`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))
        if 'p_limit' in params:
            query_params.append(('p.limit', params['p_limit']))
        if '_1_property' in params:
            query_params.append(('1_property', params['_1_property']))
        if '_1_property_value' in params:
            query_params.append(('1_property.value', params['_1_property_value']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/bin/querybuilder.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_truststore(self, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_truststore(async=True)
        >>> result = thread.get()

        :param async bool
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_truststore_with_http_info(**kwargs)
        else:
            (data) = self.get_truststore_with_http_info(**kwargs)
            return data

    def get_truststore_with_http_info(self, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_truststore_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_truststore" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/octet-stream'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/etc/truststore/truststore.p12', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='file',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_truststore_informations(self, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_truststore_informations(async=True)
        >>> result = thread.get()

        :param async bool
        :return: TruststoreInformations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_truststore_informations_with_http_info(**kwargs)
        else:
            (data) = self.get_truststore_informations_with_http_info(**kwargs)
            return data

    def get_truststore_informations_with_http_info(self, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_truststore_informations_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: TruststoreInformations
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_truststore_informations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/libs/granite/security/truststore.json', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='TruststoreInformations',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_agent(self, runmode, name, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_agent(runmode, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str name: (required)
        :param bool jcrcontentcqdistribute:
        :param str jcrcontentcqdistribute_type_hint:
        :param str jcrcontentcqname:
        :param str jcrcontentcqtemplate:
        :param bool jcrcontentenabled:
        :param str jcrcontentjcrdescription:
        :param str jcrcontentjcrlast_modified:
        :param str jcrcontentjcrlast_modified_by:
        :param str jcrcontentjcrmixin_types:
        :param str jcrcontentjcrtitle:
        :param str jcrcontentlog_level:
        :param bool jcrcontentno_status_update:
        :param bool jcrcontentno_versioning:
        :param float jcrcontentprotocol_connect_timeout:
        :param bool jcrcontentprotocol_http_connection_closed:
        :param str jcrcontentprotocol_http_expired:
        :param list[str] jcrcontentprotocol_http_headers:
        :param str jcrcontentprotocol_http_headers_type_hint:
        :param str jcrcontentprotocol_http_method:
        :param bool jcrcontentprotocol_https_relaxed:
        :param str jcrcontentprotocol_interface:
        :param float jcrcontentprotocol_socket_timeout:
        :param str jcrcontentprotocol_version:
        :param str jcrcontentproxy_ntlm_domain:
        :param str jcrcontentproxy_ntlm_host:
        :param str jcrcontentproxy_host:
        :param str jcrcontentproxy_password:
        :param float jcrcontentproxy_port:
        :param str jcrcontentproxy_user:
        :param float jcrcontentqueue_batch_max_size:
        :param str jcrcontentqueue_batch_mode:
        :param float jcrcontentqueue_batch_wait_time:
        :param str jcrcontentretry_delay:
        :param bool jcrcontentreverse_replication:
        :param str jcrcontentserialization_type:
        :param str jcrcontentslingresource_type:
        :param str jcrcontentssl:
        :param str jcrcontenttransport_ntlm_domain:
        :param str jcrcontenttransport_ntlm_host:
        :param str jcrcontenttransport_password:
        :param str jcrcontenttransport_uri:
        :param str jcrcontenttransport_user:
        :param bool jcrcontenttrigger_distribute:
        :param bool jcrcontenttrigger_modified:
        :param bool jcrcontenttrigger_on_off_time:
        :param bool jcrcontenttrigger_receive:
        :param bool jcrcontenttrigger_specific:
        :param str jcrcontentuser_id:
        :param str jcrprimary_type:
        :param str operation:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_agent_with_http_info(runmode, name, **kwargs)
        else:
            (data) = self.post_agent_with_http_info(runmode, name, **kwargs)
            return data

    def post_agent_with_http_info(self, runmode, name, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_agent_with_http_info(runmode, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str name: (required)
        :param bool jcrcontentcqdistribute:
        :param str jcrcontentcqdistribute_type_hint:
        :param str jcrcontentcqname:
        :param str jcrcontentcqtemplate:
        :param bool jcrcontentenabled:
        :param str jcrcontentjcrdescription:
        :param str jcrcontentjcrlast_modified:
        :param str jcrcontentjcrlast_modified_by:
        :param str jcrcontentjcrmixin_types:
        :param str jcrcontentjcrtitle:
        :param str jcrcontentlog_level:
        :param bool jcrcontentno_status_update:
        :param bool jcrcontentno_versioning:
        :param float jcrcontentprotocol_connect_timeout:
        :param bool jcrcontentprotocol_http_connection_closed:
        :param str jcrcontentprotocol_http_expired:
        :param list[str] jcrcontentprotocol_http_headers:
        :param str jcrcontentprotocol_http_headers_type_hint:
        :param str jcrcontentprotocol_http_method:
        :param bool jcrcontentprotocol_https_relaxed:
        :param str jcrcontentprotocol_interface:
        :param float jcrcontentprotocol_socket_timeout:
        :param str jcrcontentprotocol_version:
        :param str jcrcontentproxy_ntlm_domain:
        :param str jcrcontentproxy_ntlm_host:
        :param str jcrcontentproxy_host:
        :param str jcrcontentproxy_password:
        :param float jcrcontentproxy_port:
        :param str jcrcontentproxy_user:
        :param float jcrcontentqueue_batch_max_size:
        :param str jcrcontentqueue_batch_mode:
        :param float jcrcontentqueue_batch_wait_time:
        :param str jcrcontentretry_delay:
        :param bool jcrcontentreverse_replication:
        :param str jcrcontentserialization_type:
        :param str jcrcontentslingresource_type:
        :param str jcrcontentssl:
        :param str jcrcontenttransport_ntlm_domain:
        :param str jcrcontenttransport_ntlm_host:
        :param str jcrcontenttransport_password:
        :param str jcrcontenttransport_uri:
        :param str jcrcontenttransport_user:
        :param bool jcrcontenttrigger_distribute:
        :param bool jcrcontenttrigger_modified:
        :param bool jcrcontenttrigger_on_off_time:
        :param bool jcrcontenttrigger_receive:
        :param bool jcrcontenttrigger_specific:
        :param str jcrcontentuser_id:
        :param str jcrprimary_type:
        :param str operation:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runmode', 'name', 'jcrcontentcqdistribute', 'jcrcontentcqdistribute_type_hint', 'jcrcontentcqname', 'jcrcontentcqtemplate', 'jcrcontentenabled', 'jcrcontentjcrdescription', 'jcrcontentjcrlast_modified', 'jcrcontentjcrlast_modified_by', 'jcrcontentjcrmixin_types', 'jcrcontentjcrtitle', 'jcrcontentlog_level', 'jcrcontentno_status_update', 'jcrcontentno_versioning', 'jcrcontentprotocol_connect_timeout', 'jcrcontentprotocol_http_connection_closed', 'jcrcontentprotocol_http_expired', 'jcrcontentprotocol_http_headers', 'jcrcontentprotocol_http_headers_type_hint', 'jcrcontentprotocol_http_method', 'jcrcontentprotocol_https_relaxed', 'jcrcontentprotocol_interface', 'jcrcontentprotocol_socket_timeout', 'jcrcontentprotocol_version', 'jcrcontentproxy_ntlm_domain', 'jcrcontentproxy_ntlm_host', 'jcrcontentproxy_host', 'jcrcontentproxy_password', 'jcrcontentproxy_port', 'jcrcontentproxy_user', 'jcrcontentqueue_batch_max_size', 'jcrcontentqueue_batch_mode', 'jcrcontentqueue_batch_wait_time', 'jcrcontentretry_delay', 'jcrcontentreverse_replication', 'jcrcontentserialization_type', 'jcrcontentslingresource_type', 'jcrcontentssl', 'jcrcontenttransport_ntlm_domain', 'jcrcontenttransport_ntlm_host', 'jcrcontenttransport_password', 'jcrcontenttransport_uri', 'jcrcontenttransport_user', 'jcrcontenttrigger_distribute', 'jcrcontenttrigger_modified', 'jcrcontenttrigger_on_off_time', 'jcrcontenttrigger_receive', 'jcrcontenttrigger_specific', 'jcrcontentuser_id', 'jcrprimary_type', 'operation']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_agent" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in params) or (params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `post_agent`")
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_agent`")


        collection_formats = {}

        path_params = {}
        if 'runmode' in params:
            path_params['runmode'] = params['runmode']
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'jcrcontentcqdistribute' in params:
            query_params.append(('jcr:content/cq:distribute', params['jcrcontentcqdistribute']))
        if 'jcrcontentcqdistribute_type_hint' in params:
            query_params.append(('jcr:content/cq:distribute@TypeHint', params['jcrcontentcqdistribute_type_hint']))
        if 'jcrcontentcqname' in params:
            query_params.append(('jcr:content/cq:name', params['jcrcontentcqname']))
        if 'jcrcontentcqtemplate' in params:
            query_params.append(('jcr:content/cq:template', params['jcrcontentcqtemplate']))
        if 'jcrcontentenabled' in params:
            query_params.append(('jcr:content/enabled', params['jcrcontentenabled']))
        if 'jcrcontentjcrdescription' in params:
            query_params.append(('jcr:content/jcr:description', params['jcrcontentjcrdescription']))
        if 'jcrcontentjcrlast_modified' in params:
            query_params.append(('jcr:content/jcr:lastModified', params['jcrcontentjcrlast_modified']))
        if 'jcrcontentjcrlast_modified_by' in params:
            query_params.append(('jcr:content/jcr:lastModifiedBy', params['jcrcontentjcrlast_modified_by']))
        if 'jcrcontentjcrmixin_types' in params:
            query_params.append(('jcr:content/jcr:mixinTypes', params['jcrcontentjcrmixin_types']))
        if 'jcrcontentjcrtitle' in params:
            query_params.append(('jcr:content/jcr:title', params['jcrcontentjcrtitle']))
        if 'jcrcontentlog_level' in params:
            query_params.append(('jcr:content/logLevel', params['jcrcontentlog_level']))
        if 'jcrcontentno_status_update' in params:
            query_params.append(('jcr:content/noStatusUpdate', params['jcrcontentno_status_update']))
        if 'jcrcontentno_versioning' in params:
            query_params.append(('jcr:content/noVersioning', params['jcrcontentno_versioning']))
        if 'jcrcontentprotocol_connect_timeout' in params:
            query_params.append(('jcr:content/protocolConnectTimeout', params['jcrcontentprotocol_connect_timeout']))
        if 'jcrcontentprotocol_http_connection_closed' in params:
            query_params.append(('jcr:content/protocolHTTPConnectionClosed', params['jcrcontentprotocol_http_connection_closed']))
        if 'jcrcontentprotocol_http_expired' in params:
            query_params.append(('jcr:content/protocolHTTPExpired', params['jcrcontentprotocol_http_expired']))
        if 'jcrcontentprotocol_http_headers' in params:
            query_params.append(('jcr:content/protocolHTTPHeaders', params['jcrcontentprotocol_http_headers']))
            collection_formats['jcr:content/protocolHTTPHeaders'] = 'multi'
        if 'jcrcontentprotocol_http_headers_type_hint' in params:
            query_params.append(('jcr:content/protocolHTTPHeaders@TypeHint', params['jcrcontentprotocol_http_headers_type_hint']))
        if 'jcrcontentprotocol_http_method' in params:
            query_params.append(('jcr:content/protocolHTTPMethod', params['jcrcontentprotocol_http_method']))
        if 'jcrcontentprotocol_https_relaxed' in params:
            query_params.append(('jcr:content/protocolHTTPSRelaxed', params['jcrcontentprotocol_https_relaxed']))
        if 'jcrcontentprotocol_interface' in params:
            query_params.append(('jcr:content/protocolInterface', params['jcrcontentprotocol_interface']))
        if 'jcrcontentprotocol_socket_timeout' in params:
            query_params.append(('jcr:content/protocolSocketTimeout', params['jcrcontentprotocol_socket_timeout']))
        if 'jcrcontentprotocol_version' in params:
            query_params.append(('jcr:content/protocolVersion', params['jcrcontentprotocol_version']))
        if 'jcrcontentproxy_ntlm_domain' in params:
            query_params.append(('jcr:content/proxyNTLMDomain', params['jcrcontentproxy_ntlm_domain']))
        if 'jcrcontentproxy_ntlm_host' in params:
            query_params.append(('jcr:content/proxyNTLMHost', params['jcrcontentproxy_ntlm_host']))
        if 'jcrcontentproxy_host' in params:
            query_params.append(('jcr:content/proxyHost', params['jcrcontentproxy_host']))
        if 'jcrcontentproxy_password' in params:
            query_params.append(('jcr:content/proxyPassword', params['jcrcontentproxy_password']))
        if 'jcrcontentproxy_port' in params:
            query_params.append(('jcr:content/proxyPort', params['jcrcontentproxy_port']))
        if 'jcrcontentproxy_user' in params:
            query_params.append(('jcr:content/proxyUser', params['jcrcontentproxy_user']))
        if 'jcrcontentqueue_batch_max_size' in params:
            query_params.append(('jcr:content/queueBatchMaxSize', params['jcrcontentqueue_batch_max_size']))
        if 'jcrcontentqueue_batch_mode' in params:
            query_params.append(('jcr:content/queueBatchMode', params['jcrcontentqueue_batch_mode']))
        if 'jcrcontentqueue_batch_wait_time' in params:
            query_params.append(('jcr:content/queueBatchWaitTime', params['jcrcontentqueue_batch_wait_time']))
        if 'jcrcontentretry_delay' in params:
            query_params.append(('jcr:content/retryDelay', params['jcrcontentretry_delay']))
        if 'jcrcontentreverse_replication' in params:
            query_params.append(('jcr:content/reverseReplication', params['jcrcontentreverse_replication']))
        if 'jcrcontentserialization_type' in params:
            query_params.append(('jcr:content/serializationType', params['jcrcontentserialization_type']))
        if 'jcrcontentslingresource_type' in params:
            query_params.append(('jcr:content/sling:resourceType', params['jcrcontentslingresource_type']))
        if 'jcrcontentssl' in params:
            query_params.append(('jcr:content/ssl', params['jcrcontentssl']))
        if 'jcrcontenttransport_ntlm_domain' in params:
            query_params.append(('jcr:content/transportNTLMDomain', params['jcrcontenttransport_ntlm_domain']))
        if 'jcrcontenttransport_ntlm_host' in params:
            query_params.append(('jcr:content/transportNTLMHost', params['jcrcontenttransport_ntlm_host']))
        if 'jcrcontenttransport_password' in params:
            query_params.append(('jcr:content/transportPassword', params['jcrcontenttransport_password']))
        if 'jcrcontenttransport_uri' in params:
            query_params.append(('jcr:content/transportUri', params['jcrcontenttransport_uri']))
        if 'jcrcontenttransport_user' in params:
            query_params.append(('jcr:content/transportUser', params['jcrcontenttransport_user']))
        if 'jcrcontenttrigger_distribute' in params:
            query_params.append(('jcr:content/triggerDistribute', params['jcrcontenttrigger_distribute']))
        if 'jcrcontenttrigger_modified' in params:
            query_params.append(('jcr:content/triggerModified', params['jcrcontenttrigger_modified']))
        if 'jcrcontenttrigger_on_off_time' in params:
            query_params.append(('jcr:content/triggerOnOffTime', params['jcrcontenttrigger_on_off_time']))
        if 'jcrcontenttrigger_receive' in params:
            query_params.append(('jcr:content/triggerReceive', params['jcrcontenttrigger_receive']))
        if 'jcrcontenttrigger_specific' in params:
            query_params.append(('jcr:content/triggerSpecific', params['jcrcontenttrigger_specific']))
        if 'jcrcontentuser_id' in params:
            query_params.append(('jcr:content/userId', params['jcrcontentuser_id']))
        if 'jcrprimary_type' in params:
            query_params.append(('jcr:primaryType', params['jcrprimary_type']))
        if 'operation' in params:
            query_params.append((':operation', params['operation']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/etc/replication/agents.{runmode}/{name}', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_authorizable_keystore(self, intermediate_path, authorizable_id, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_authorizable_keystore(intermediate_path, authorizable_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str intermediate_path: (required)
        :param str authorizable_id: (required)
        :param str operation:
        :param str current_password:
        :param str new_password:
        :param str re_password:
        :param str key_password:
        :param str key_store_pass:
        :param str operation2:
        :param str alias:
        :param str new_alias:
        :param str remove_alias:
        :param file cert_chain:
        :param file pk:
        :param file key_store:
        :return: KeystoreInformations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_authorizable_keystore_with_http_info(intermediate_path, authorizable_id, **kwargs)
        else:
            (data) = self.post_authorizable_keystore_with_http_info(intermediate_path, authorizable_id, **kwargs)
            return data

    def post_authorizable_keystore_with_http_info(self, intermediate_path, authorizable_id, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_authorizable_keystore_with_http_info(intermediate_path, authorizable_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str intermediate_path: (required)
        :param str authorizable_id: (required)
        :param str operation:
        :param str current_password:
        :param str new_password:
        :param str re_password:
        :param str key_password:
        :param str key_store_pass:
        :param str operation2:
        :param str alias:
        :param str new_alias:
        :param str remove_alias:
        :param file cert_chain:
        :param file pk:
        :param file key_store:
        :return: KeystoreInformations
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['intermediate_path', 'authorizable_id', 'operation', 'current_password', 'new_password', 're_password', 'key_password', 'key_store_pass', 'operation2', 'alias', 'new_alias', 'remove_alias', 'cert_chain', 'pk', 'key_store']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_authorizable_keystore" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'intermediate_path' is set
        if ('intermediate_path' not in params) or (params['intermediate_path'] is None):
            raise ValueError("Missing the required parameter `intermediate_path` when calling `post_authorizable_keystore`")
        # verify the required parameter 'authorizable_id' is set
        if ('authorizable_id' not in params) or (params['authorizable_id'] is None):
            raise ValueError("Missing the required parameter `authorizable_id` when calling `post_authorizable_keystore`")


        collection_formats = {}

        path_params = {}
        if 'intermediate_path' in params:
            path_params['intermediatePath'] = params['intermediate_path']
        if 'authorizable_id' in params:
            path_params['authorizableId'] = params['authorizable_id']

        query_params = []
        if 'operation' in params:
            query_params.append((':operation', params['operation']))
        if 'current_password' in params:
            query_params.append(('currentPassword', params['current_password']))
        if 'new_password' in params:
            query_params.append(('newPassword', params['new_password']))
        if 're_password' in params:
            query_params.append(('rePassword', params['re_password']))
        if 'key_password' in params:
            query_params.append(('keyPassword', params['key_password']))
        if 'key_store_pass' in params:
            query_params.append(('keyStorePass', params['key_store_pass']))
        if 'operation2' in params:
            query_params.append((':operation', params['operation2']))
        if 'alias' in params:
            query_params.append(('alias', params['alias']))
        if 'new_alias' in params:
            query_params.append(('newAlias', params['new_alias']))
        if 'remove_alias' in params:
            query_params.append(('removeAlias', params['remove_alias']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'cert_chain' in params:
            local_var_files['cert-chain'] = params['cert_chain']
        if 'pk' in params:
            local_var_files['pk'] = params['pk']
        if 'key_store' in params:
            local_var_files['keyStore'] = params['key_store']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/{intermediatePath}/{authorizableId}.ks.html', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='KeystoreInformations',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_authorizables(self, authorizable_id, intermediate_path, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_authorizables(authorizable_id, intermediate_path, async=True)
        >>> result = thread.get()

        :param async bool
        :param str authorizable_id: (required)
        :param str intermediate_path: (required)
        :param str create_user:
        :param str create_group:
        :param str reppassword:
        :param str profilegiven_name:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_authorizables_with_http_info(authorizable_id, intermediate_path, **kwargs)
        else:
            (data) = self.post_authorizables_with_http_info(authorizable_id, intermediate_path, **kwargs)
            return data

    def post_authorizables_with_http_info(self, authorizable_id, intermediate_path, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_authorizables_with_http_info(authorizable_id, intermediate_path, async=True)
        >>> result = thread.get()

        :param async bool
        :param str authorizable_id: (required)
        :param str intermediate_path: (required)
        :param str create_user:
        :param str create_group:
        :param str reppassword:
        :param str profilegiven_name:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorizable_id', 'intermediate_path', 'create_user', 'create_group', 'reppassword', 'profilegiven_name']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_authorizables" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'authorizable_id' is set
        if ('authorizable_id' not in params) or (params['authorizable_id'] is None):
            raise ValueError("Missing the required parameter `authorizable_id` when calling `post_authorizables`")
        # verify the required parameter 'intermediate_path' is set
        if ('intermediate_path' not in params) or (params['intermediate_path'] is None):
            raise ValueError("Missing the required parameter `intermediate_path` when calling `post_authorizables`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'authorizable_id' in params:
            query_params.append(('authorizableId', params['authorizable_id']))
        if 'intermediate_path' in params:
            query_params.append(('intermediatePath', params['intermediate_path']))
        if 'create_user' in params:
            query_params.append(('createUser', params['create_user']))
        if 'create_group' in params:
            query_params.append(('createGroup', params['create_group']))
        if 'reppassword' in params:
            query_params.append(('rep:password', params['reppassword']))
        if 'profilegiven_name' in params:
            query_params.append(('profile/givenName', params['profilegiven_name']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/html'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/libs/granite/security/post/authorizables', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_config_adobe_granite_saml_authentication_handler(self, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_adobe_granite_saml_authentication_handler(async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_store_password:
        :param str key_store_password_type_hint:
        :param int service_ranking:
        :param str service_ranking_type_hint:
        :param bool idp_http_redirect:
        :param str idp_http_redirect_type_hint:
        :param bool create_user:
        :param str create_user_type_hint:
        :param str default_redirect_url:
        :param str default_redirect_url_type_hint:
        :param str user_id_attribute:
        :param str user_id_attribute_type_hint:
        :param list[str] default_groups:
        :param str default_groups_type_hint:
        :param str idp_cert_alias:
        :param str idp_cert_alias_type_hint:
        :param bool add_group_memberships:
        :param str add_group_memberships_type_hint:
        :param list[str] path:
        :param str path_type_hint:
        :param list[str] synchronize_attributes:
        :param str synchronize_attributes_type_hint:
        :param int clock_tolerance:
        :param str clock_tolerance_type_hint:
        :param str group_membership_attribute:
        :param str group_membership_attribute_type_hint:
        :param str idp_url:
        :param str idp_url_type_hint:
        :param str logout_url:
        :param str logout_url_type_hint:
        :param str service_provider_entity_id:
        :param str service_provider_entity_id_type_hint:
        :param str assertion_consumer_service_url:
        :param str assertion_consumer_service_url_type_hint:
        :param bool handle_logout:
        :param str handle_logout_type_hint:
        :param str sp_private_key_alias:
        :param str sp_private_key_alias_type_hint:
        :param bool use_encryption:
        :param str use_encryption_type_hint:
        :param str name_id_format:
        :param str name_id_format_type_hint:
        :param str digest_method:
        :param str digest_method_type_hint:
        :param str signature_method:
        :param str signature_method_type_hint:
        :param str user_intermediate_path:
        :param str user_intermediate_path_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_config_adobe_granite_saml_authentication_handler_with_http_info(**kwargs)
        else:
            (data) = self.post_config_adobe_granite_saml_authentication_handler_with_http_info(**kwargs)
            return data

    def post_config_adobe_granite_saml_authentication_handler_with_http_info(self, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_adobe_granite_saml_authentication_handler_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str key_store_password:
        :param str key_store_password_type_hint:
        :param int service_ranking:
        :param str service_ranking_type_hint:
        :param bool idp_http_redirect:
        :param str idp_http_redirect_type_hint:
        :param bool create_user:
        :param str create_user_type_hint:
        :param str default_redirect_url:
        :param str default_redirect_url_type_hint:
        :param str user_id_attribute:
        :param str user_id_attribute_type_hint:
        :param list[str] default_groups:
        :param str default_groups_type_hint:
        :param str idp_cert_alias:
        :param str idp_cert_alias_type_hint:
        :param bool add_group_memberships:
        :param str add_group_memberships_type_hint:
        :param list[str] path:
        :param str path_type_hint:
        :param list[str] synchronize_attributes:
        :param str synchronize_attributes_type_hint:
        :param int clock_tolerance:
        :param str clock_tolerance_type_hint:
        :param str group_membership_attribute:
        :param str group_membership_attribute_type_hint:
        :param str idp_url:
        :param str idp_url_type_hint:
        :param str logout_url:
        :param str logout_url_type_hint:
        :param str service_provider_entity_id:
        :param str service_provider_entity_id_type_hint:
        :param str assertion_consumer_service_url:
        :param str assertion_consumer_service_url_type_hint:
        :param bool handle_logout:
        :param str handle_logout_type_hint:
        :param str sp_private_key_alias:
        :param str sp_private_key_alias_type_hint:
        :param bool use_encryption:
        :param str use_encryption_type_hint:
        :param str name_id_format:
        :param str name_id_format_type_hint:
        :param str digest_method:
        :param str digest_method_type_hint:
        :param str signature_method:
        :param str signature_method_type_hint:
        :param str user_intermediate_path:
        :param str user_intermediate_path_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['key_store_password', 'key_store_password_type_hint', 'service_ranking', 'service_ranking_type_hint', 'idp_http_redirect', 'idp_http_redirect_type_hint', 'create_user', 'create_user_type_hint', 'default_redirect_url', 'default_redirect_url_type_hint', 'user_id_attribute', 'user_id_attribute_type_hint', 'default_groups', 'default_groups_type_hint', 'idp_cert_alias', 'idp_cert_alias_type_hint', 'add_group_memberships', 'add_group_memberships_type_hint', 'path', 'path_type_hint', 'synchronize_attributes', 'synchronize_attributes_type_hint', 'clock_tolerance', 'clock_tolerance_type_hint', 'group_membership_attribute', 'group_membership_attribute_type_hint', 'idp_url', 'idp_url_type_hint', 'logout_url', 'logout_url_type_hint', 'service_provider_entity_id', 'service_provider_entity_id_type_hint', 'assertion_consumer_service_url', 'assertion_consumer_service_url_type_hint', 'handle_logout', 'handle_logout_type_hint', 'sp_private_key_alias', 'sp_private_key_alias_type_hint', 'use_encryption', 'use_encryption_type_hint', 'name_id_format', 'name_id_format_type_hint', 'digest_method', 'digest_method_type_hint', 'signature_method', 'signature_method_type_hint', 'user_intermediate_path', 'user_intermediate_path_type_hint']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_adobe_granite_saml_authentication_handler" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'key_store_password' in params:
            query_params.append(('keyStorePassword', params['key_store_password']))
        if 'key_store_password_type_hint' in params:
            query_params.append(('keyStorePassword@TypeHint', params['key_store_password_type_hint']))
        if 'service_ranking' in params:
            query_params.append(('service.ranking', params['service_ranking']))
        if 'service_ranking_type_hint' in params:
            query_params.append(('service.ranking@TypeHint', params['service_ranking_type_hint']))
        if 'idp_http_redirect' in params:
            query_params.append(('idpHttpRedirect', params['idp_http_redirect']))
        if 'idp_http_redirect_type_hint' in params:
            query_params.append(('idpHttpRedirect@TypeHint', params['idp_http_redirect_type_hint']))
        if 'create_user' in params:
            query_params.append(('createUser', params['create_user']))
        if 'create_user_type_hint' in params:
            query_params.append(('createUser@TypeHint', params['create_user_type_hint']))
        if 'default_redirect_url' in params:
            query_params.append(('defaultRedirectUrl', params['default_redirect_url']))
        if 'default_redirect_url_type_hint' in params:
            query_params.append(('defaultRedirectUrl@TypeHint', params['default_redirect_url_type_hint']))
        if 'user_id_attribute' in params:
            query_params.append(('userIDAttribute', params['user_id_attribute']))
        if 'user_id_attribute_type_hint' in params:
            query_params.append(('userIDAttribute@TypeHint', params['user_id_attribute_type_hint']))
        if 'default_groups' in params:
            query_params.append(('defaultGroups', params['default_groups']))
            collection_formats['defaultGroups'] = 'multi'
        if 'default_groups_type_hint' in params:
            query_params.append(('defaultGroups@TypeHint', params['default_groups_type_hint']))
        if 'idp_cert_alias' in params:
            query_params.append(('idpCertAlias', params['idp_cert_alias']))
        if 'idp_cert_alias_type_hint' in params:
            query_params.append(('idpCertAlias@TypeHint', params['idp_cert_alias_type_hint']))
        if 'add_group_memberships' in params:
            query_params.append(('addGroupMemberships', params['add_group_memberships']))
        if 'add_group_memberships_type_hint' in params:
            query_params.append(('addGroupMemberships@TypeHint', params['add_group_memberships_type_hint']))
        if 'path' in params:
            query_params.append(('path', params['path']))
            collection_formats['path'] = 'multi'
        if 'path_type_hint' in params:
            query_params.append(('path@TypeHint', params['path_type_hint']))
        if 'synchronize_attributes' in params:
            query_params.append(('synchronizeAttributes', params['synchronize_attributes']))
            collection_formats['synchronizeAttributes'] = 'multi'
        if 'synchronize_attributes_type_hint' in params:
            query_params.append(('synchronizeAttributes@TypeHint', params['synchronize_attributes_type_hint']))
        if 'clock_tolerance' in params:
            query_params.append(('clockTolerance', params['clock_tolerance']))
        if 'clock_tolerance_type_hint' in params:
            query_params.append(('clockTolerance@TypeHint', params['clock_tolerance_type_hint']))
        if 'group_membership_attribute' in params:
            query_params.append(('groupMembershipAttribute', params['group_membership_attribute']))
        if 'group_membership_attribute_type_hint' in params:
            query_params.append(('groupMembershipAttribute@TypeHint', params['group_membership_attribute_type_hint']))
        if 'idp_url' in params:
            query_params.append(('idpUrl', params['idp_url']))
        if 'idp_url_type_hint' in params:
            query_params.append(('idpUrl@TypeHint', params['idp_url_type_hint']))
        if 'logout_url' in params:
            query_params.append(('logoutUrl', params['logout_url']))
        if 'logout_url_type_hint' in params:
            query_params.append(('logoutUrl@TypeHint', params['logout_url_type_hint']))
        if 'service_provider_entity_id' in params:
            query_params.append(('serviceProviderEntityId', params['service_provider_entity_id']))
        if 'service_provider_entity_id_type_hint' in params:
            query_params.append(('serviceProviderEntityId@TypeHint', params['service_provider_entity_id_type_hint']))
        if 'assertion_consumer_service_url' in params:
            query_params.append(('assertionConsumerServiceURL', params['assertion_consumer_service_url']))
        if 'assertion_consumer_service_url_type_hint' in params:
            query_params.append(('assertionConsumerServiceURL@TypeHint', params['assertion_consumer_service_url_type_hint']))
        if 'handle_logout' in params:
            query_params.append(('handleLogout', params['handle_logout']))
        if 'handle_logout_type_hint' in params:
            query_params.append(('handleLogout@TypeHint', params['handle_logout_type_hint']))
        if 'sp_private_key_alias' in params:
            query_params.append(('spPrivateKeyAlias', params['sp_private_key_alias']))
        if 'sp_private_key_alias_type_hint' in params:
            query_params.append(('spPrivateKeyAlias@TypeHint', params['sp_private_key_alias_type_hint']))
        if 'use_encryption' in params:
            query_params.append(('useEncryption', params['use_encryption']))
        if 'use_encryption_type_hint' in params:
            query_params.append(('useEncryption@TypeHint', params['use_encryption_type_hint']))
        if 'name_id_format' in params:
            query_params.append(('nameIdFormat', params['name_id_format']))
        if 'name_id_format_type_hint' in params:
            query_params.append(('nameIdFormat@TypeHint', params['name_id_format_type_hint']))
        if 'digest_method' in params:
            query_params.append(('digestMethod', params['digest_method']))
        if 'digest_method_type_hint' in params:
            query_params.append(('digestMethod@TypeHint', params['digest_method_type_hint']))
        if 'signature_method' in params:
            query_params.append(('signatureMethod', params['signature_method']))
        if 'signature_method_type_hint' in params:
            query_params.append(('signatureMethod@TypeHint', params['signature_method_type_hint']))
        if 'user_intermediate_path' in params:
            query_params.append(('userIntermediatePath', params['user_intermediate_path']))
        if 'user_intermediate_path_type_hint' in params:
            query_params.append(('userIntermediatePath@TypeHint', params['user_intermediate_path_type_hint']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_config_apache_felix_jetty_based_http_service(self, runmode, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_apache_felix_jetty_based_http_service(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param bool org_apache_felix_https_nio:
        :param str org_apache_felix_https_nio_type_hint:
        :param str org_apache_felix_https_keystore:
        :param str org_apache_felix_https_keystore_type_hint:
        :param str org_apache_felix_https_keystore_password:
        :param str org_apache_felix_https_keystore_password_type_hint:
        :param str org_apache_felix_https_keystore_key:
        :param str org_apache_felix_https_keystore_key_type_hint:
        :param str org_apache_felix_https_keystore_key_password:
        :param str org_apache_felix_https_keystore_key_password_type_hint:
        :param str org_apache_felix_https_truststore:
        :param str org_apache_felix_https_truststore_type_hint:
        :param str org_apache_felix_https_truststore_password:
        :param str org_apache_felix_https_truststore_password_type_hint:
        :param str org_apache_felix_https_clientcertificate:
        :param str org_apache_felix_https_clientcertificate_type_hint:
        :param bool org_apache_felix_https_enable:
        :param str org_apache_felix_https_enable_type_hint:
        :param str org_osgi_service_http_port_secure:
        :param str org_osgi_service_http_port_secure_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_config_apache_felix_jetty_based_http_service_with_http_info(runmode, **kwargs)
        else:
            (data) = self.post_config_apache_felix_jetty_based_http_service_with_http_info(runmode, **kwargs)
            return data

    def post_config_apache_felix_jetty_based_http_service_with_http_info(self, runmode, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_apache_felix_jetty_based_http_service_with_http_info(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param bool org_apache_felix_https_nio:
        :param str org_apache_felix_https_nio_type_hint:
        :param str org_apache_felix_https_keystore:
        :param str org_apache_felix_https_keystore_type_hint:
        :param str org_apache_felix_https_keystore_password:
        :param str org_apache_felix_https_keystore_password_type_hint:
        :param str org_apache_felix_https_keystore_key:
        :param str org_apache_felix_https_keystore_key_type_hint:
        :param str org_apache_felix_https_keystore_key_password:
        :param str org_apache_felix_https_keystore_key_password_type_hint:
        :param str org_apache_felix_https_truststore:
        :param str org_apache_felix_https_truststore_type_hint:
        :param str org_apache_felix_https_truststore_password:
        :param str org_apache_felix_https_truststore_password_type_hint:
        :param str org_apache_felix_https_clientcertificate:
        :param str org_apache_felix_https_clientcertificate_type_hint:
        :param bool org_apache_felix_https_enable:
        :param str org_apache_felix_https_enable_type_hint:
        :param str org_osgi_service_http_port_secure:
        :param str org_osgi_service_http_port_secure_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runmode', 'org_apache_felix_https_nio', 'org_apache_felix_https_nio_type_hint', 'org_apache_felix_https_keystore', 'org_apache_felix_https_keystore_type_hint', 'org_apache_felix_https_keystore_password', 'org_apache_felix_https_keystore_password_type_hint', 'org_apache_felix_https_keystore_key', 'org_apache_felix_https_keystore_key_type_hint', 'org_apache_felix_https_keystore_key_password', 'org_apache_felix_https_keystore_key_password_type_hint', 'org_apache_felix_https_truststore', 'org_apache_felix_https_truststore_type_hint', 'org_apache_felix_https_truststore_password', 'org_apache_felix_https_truststore_password_type_hint', 'org_apache_felix_https_clientcertificate', 'org_apache_felix_https_clientcertificate_type_hint', 'org_apache_felix_https_enable', 'org_apache_felix_https_enable_type_hint', 'org_osgi_service_http_port_secure', 'org_osgi_service_http_port_secure_type_hint']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_apache_felix_jetty_based_http_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in params) or (params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `post_config_apache_felix_jetty_based_http_service`")


        collection_formats = {}

        path_params = {}
        if 'runmode' in params:
            path_params['runmode'] = params['runmode']

        query_params = []
        if 'org_apache_felix_https_nio' in params:
            query_params.append(('org.apache.felix.https.nio', params['org_apache_felix_https_nio']))
        if 'org_apache_felix_https_nio_type_hint' in params:
            query_params.append(('org.apache.felix.https.nio@TypeHint', params['org_apache_felix_https_nio_type_hint']))
        if 'org_apache_felix_https_keystore' in params:
            query_params.append(('org.apache.felix.https.keystore', params['org_apache_felix_https_keystore']))
        if 'org_apache_felix_https_keystore_type_hint' in params:
            query_params.append(('org.apache.felix.https.keystore@TypeHint', params['org_apache_felix_https_keystore_type_hint']))
        if 'org_apache_felix_https_keystore_password' in params:
            query_params.append(('org.apache.felix.https.keystore.password', params['org_apache_felix_https_keystore_password']))
        if 'org_apache_felix_https_keystore_password_type_hint' in params:
            query_params.append(('org.apache.felix.https.keystore.password@TypeHint', params['org_apache_felix_https_keystore_password_type_hint']))
        if 'org_apache_felix_https_keystore_key' in params:
            query_params.append(('org.apache.felix.https.keystore.key', params['org_apache_felix_https_keystore_key']))
        if 'org_apache_felix_https_keystore_key_type_hint' in params:
            query_params.append(('org.apache.felix.https.keystore.key@TypeHint', params['org_apache_felix_https_keystore_key_type_hint']))
        if 'org_apache_felix_https_keystore_key_password' in params:
            query_params.append(('org.apache.felix.https.keystore.key.password', params['org_apache_felix_https_keystore_key_password']))
        if 'org_apache_felix_https_keystore_key_password_type_hint' in params:
            query_params.append(('org.apache.felix.https.keystore.key.password@TypeHint', params['org_apache_felix_https_keystore_key_password_type_hint']))
        if 'org_apache_felix_https_truststore' in params:
            query_params.append(('org.apache.felix.https.truststore', params['org_apache_felix_https_truststore']))
        if 'org_apache_felix_https_truststore_type_hint' in params:
            query_params.append(('org.apache.felix.https.truststore@TypeHint', params['org_apache_felix_https_truststore_type_hint']))
        if 'org_apache_felix_https_truststore_password' in params:
            query_params.append(('org.apache.felix.https.truststore.password', params['org_apache_felix_https_truststore_password']))
        if 'org_apache_felix_https_truststore_password_type_hint' in params:
            query_params.append(('org.apache.felix.https.truststore.password@TypeHint', params['org_apache_felix_https_truststore_password_type_hint']))
        if 'org_apache_felix_https_clientcertificate' in params:
            query_params.append(('org.apache.felix.https.clientcertificate', params['org_apache_felix_https_clientcertificate']))
        if 'org_apache_felix_https_clientcertificate_type_hint' in params:
            query_params.append(('org.apache.felix.https.clientcertificate@TypeHint', params['org_apache_felix_https_clientcertificate_type_hint']))
        if 'org_apache_felix_https_enable' in params:
            query_params.append(('org.apache.felix.https.enable', params['org_apache_felix_https_enable']))
        if 'org_apache_felix_https_enable_type_hint' in params:
            query_params.append(('org.apache.felix.https.enable@TypeHint', params['org_apache_felix_https_enable_type_hint']))
        if 'org_osgi_service_http_port_secure' in params:
            query_params.append(('org.osgi.service.http.port.secure', params['org_osgi_service_http_port_secure']))
        if 'org_osgi_service_http_port_secure_type_hint' in params:
            query_params.append(('org.osgi.service.http.port.secure@TypeHint', params['org_osgi_service_http_port_secure_type_hint']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/apps/system/config/org.apache.felix.http', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_config_apache_sling_dav_ex_servlet(self, runmode, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_apache_sling_dav_ex_servlet(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str alias:
        :param str alias_type_hint:
        :param bool dav_create_absolute_uri:
        :param str dav_create_absolute_uri_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_config_apache_sling_dav_ex_servlet_with_http_info(runmode, **kwargs)
        else:
            (data) = self.post_config_apache_sling_dav_ex_servlet_with_http_info(runmode, **kwargs)
            return data

    def post_config_apache_sling_dav_ex_servlet_with_http_info(self, runmode, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_apache_sling_dav_ex_servlet_with_http_info(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str alias:
        :param str alias_type_hint:
        :param bool dav_create_absolute_uri:
        :param str dav_create_absolute_uri_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runmode', 'alias', 'alias_type_hint', 'dav_create_absolute_uri', 'dav_create_absolute_uri_type_hint']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_apache_sling_dav_ex_servlet" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in params) or (params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `post_config_apache_sling_dav_ex_servlet`")


        collection_formats = {}

        path_params = {}
        if 'runmode' in params:
            path_params['runmode'] = params['runmode']

        query_params = []
        if 'alias' in params:
            query_params.append(('alias', params['alias']))
        if 'alias_type_hint' in params:
            query_params.append(('alias@TypeHint', params['alias_type_hint']))
        if 'dav_create_absolute_uri' in params:
            query_params.append(('dav.create-absolute-uri', params['dav_create_absolute_uri']))
        if 'dav_create_absolute_uri_type_hint' in params:
            query_params.append(('dav.create-absolute-uri@TypeHint', params['dav_create_absolute_uri_type_hint']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_config_apache_sling_get_servlet(self, runmode, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_apache_sling_get_servlet(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str json_maximumresults:
        :param str json_maximumresults_type_hint:
        :param bool enable_html:
        :param str enable_html_type_hint:
        :param bool enable_txt:
        :param str enable_txt_type_hint:
        :param bool enable_xml:
        :param str enable_xml_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_config_apache_sling_get_servlet_with_http_info(runmode, **kwargs)
        else:
            (data) = self.post_config_apache_sling_get_servlet_with_http_info(runmode, **kwargs)
            return data

    def post_config_apache_sling_get_servlet_with_http_info(self, runmode, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_apache_sling_get_servlet_with_http_info(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param str json_maximumresults:
        :param str json_maximumresults_type_hint:
        :param bool enable_html:
        :param str enable_html_type_hint:
        :param bool enable_txt:
        :param str enable_txt_type_hint:
        :param bool enable_xml:
        :param str enable_xml_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runmode', 'json_maximumresults', 'json_maximumresults_type_hint', 'enable_html', 'enable_html_type_hint', 'enable_txt', 'enable_txt_type_hint', 'enable_xml', 'enable_xml_type_hint']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_apache_sling_get_servlet" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in params) or (params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `post_config_apache_sling_get_servlet`")


        collection_formats = {}

        path_params = {}
        if 'runmode' in params:
            path_params['runmode'] = params['runmode']

        query_params = []
        if 'json_maximumresults' in params:
            query_params.append(('json.maximumresults', params['json_maximumresults']))
        if 'json_maximumresults_type_hint' in params:
            query_params.append(('json.maximumresults@TypeHint', params['json_maximumresults_type_hint']))
        if 'enable_html' in params:
            query_params.append(('enable.html', params['enable_html']))
        if 'enable_html_type_hint' in params:
            query_params.append(('enable.html@TypeHint', params['enable_html_type_hint']))
        if 'enable_txt' in params:
            query_params.append(('enable.txt', params['enable_txt']))
        if 'enable_txt_type_hint' in params:
            query_params.append(('enable.txt@TypeHint', params['enable_txt_type_hint']))
        if 'enable_xml' in params:
            query_params.append(('enable.xml', params['enable_xml']))
        if 'enable_xml_type_hint' in params:
            query_params.append(('enable.xml@TypeHint', params['enable_xml_type_hint']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_config_apache_sling_referrer_filter(self, runmode, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_apache_sling_referrer_filter(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param bool allow_empty:
        :param str allow_empty_type_hint:
        :param str allow_hosts:
        :param str allow_hosts_type_hint:
        :param str allow_hosts_regexp:
        :param str allow_hosts_regexp_type_hint:
        :param str filter_methods:
        :param str filter_methods_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_config_apache_sling_referrer_filter_with_http_info(runmode, **kwargs)
        else:
            (data) = self.post_config_apache_sling_referrer_filter_with_http_info(runmode, **kwargs)
            return data

    def post_config_apache_sling_referrer_filter_with_http_info(self, runmode, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_config_apache_sling_referrer_filter_with_http_info(runmode, async=True)
        >>> result = thread.get()

        :param async bool
        :param str runmode: (required)
        :param bool allow_empty:
        :param str allow_empty_type_hint:
        :param str allow_hosts:
        :param str allow_hosts_type_hint:
        :param str allow_hosts_regexp:
        :param str allow_hosts_regexp_type_hint:
        :param str filter_methods:
        :param str filter_methods_type_hint:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runmode', 'allow_empty', 'allow_empty_type_hint', 'allow_hosts', 'allow_hosts_type_hint', 'allow_hosts_regexp', 'allow_hosts_regexp_type_hint', 'filter_methods', 'filter_methods_type_hint']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_config_apache_sling_referrer_filter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runmode' is set
        if ('runmode' not in params) or (params['runmode'] is None):
            raise ValueError("Missing the required parameter `runmode` when calling `post_config_apache_sling_referrer_filter`")


        collection_formats = {}

        path_params = {}
        if 'runmode' in params:
            path_params['runmode'] = params['runmode']

        query_params = []
        if 'allow_empty' in params:
            query_params.append(('allow.empty', params['allow_empty']))
        if 'allow_empty_type_hint' in params:
            query_params.append(('allow.empty@TypeHint', params['allow_empty_type_hint']))
        if 'allow_hosts' in params:
            query_params.append(('allow.hosts', params['allow_hosts']))
        if 'allow_hosts_type_hint' in params:
            query_params.append(('allow.hosts@TypeHint', params['allow_hosts_type_hint']))
        if 'allow_hosts_regexp' in params:
            query_params.append(('allow.hosts.regexp', params['allow_hosts_regexp']))
        if 'allow_hosts_regexp_type_hint' in params:
            query_params.append(('allow.hosts.regexp@TypeHint', params['allow_hosts_regexp_type_hint']))
        if 'filter_methods' in params:
            query_params.append(('filter.methods', params['filter_methods']))
        if 'filter_methods_type_hint' in params:
            query_params.append(('filter.methods@TypeHint', params['filter_methods_type_hint']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/apps/system/config/org.apache.sling.security.impl.ReferrerFilter', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_node(self, path, name, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_node(path, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str name: (required)
        :param str operation:
        :param str delete_authorizable:
        :param file file:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_node_with_http_info(path, name, **kwargs)
        else:
            (data) = self.post_node_with_http_info(path, name, **kwargs)
            return data

    def post_node_with_http_info(self, path, name, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_node_with_http_info(path, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str name: (required)
        :param str operation:
        :param str delete_authorizable:
        :param file file:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'name', 'operation', 'delete_authorizable', 'file']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `post_node`")
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_node`")


        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'operation' in params:
            query_params.append((':operation', params['operation']))
        if 'delete_authorizable' in params:
            query_params.append(('deleteAuthorizable', params['delete_authorizable']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/{path}/{name}', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_node_rw(self, path, name, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_node_rw(path, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str name: (required)
        :param str add_members:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_node_rw_with_http_info(path, name, **kwargs)
        else:
            (data) = self.post_node_rw_with_http_info(path, name, **kwargs)
            return data

    def post_node_rw_with_http_info(self, path, name, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_node_rw_with_http_info(path, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str name: (required)
        :param str add_members:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'name', 'add_members']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_node_rw" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `post_node_rw`")
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_node_rw`")


        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'add_members' in params:
            query_params.append(('addMembers', params['add_members']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/{path}/{name}.rw.html', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_path(self, path, jcrprimary_type, name, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_path(path, jcrprimary_type, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str jcrprimary_type: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_path_with_http_info(path, jcrprimary_type, name, **kwargs)
        else:
            (data) = self.post_path_with_http_info(path, jcrprimary_type, name, **kwargs)
            return data

    def post_path_with_http_info(self, path, jcrprimary_type, name, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_path_with_http_info(path, jcrprimary_type, name, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param str jcrprimary_type: (required)
        :param str name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'jcrprimary_type', 'name']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_path" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `post_path`")
        # verify the required parameter 'jcrprimary_type' is set
        if ('jcrprimary_type' not in params) or (params['jcrprimary_type'] is None):
            raise ValueError("Missing the required parameter `jcrprimary_type` when calling `post_path`")
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_path`")


        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']

        query_params = []
        if 'jcrprimary_type' in params:
            query_params.append(('jcr:primaryType', params['jcrprimary_type']))
        if 'name' in params:
            query_params.append((':name', params['name']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/{path}/', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_query(self, path, p_limit, _1_property, _1_property_value, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_query(path, p_limit, _1_property, _1_property_value, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param float p_limit: (required)
        :param str _1_property: (required)
        :param str _1_property_value: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_query_with_http_info(path, p_limit, _1_property, _1_property_value, **kwargs)
        else:
            (data) = self.post_query_with_http_info(path, p_limit, _1_property, _1_property_value, **kwargs)
            return data

    def post_query_with_http_info(self, path, p_limit, _1_property, _1_property_value, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_query_with_http_info(path, p_limit, _1_property, _1_property_value, async=True)
        >>> result = thread.get()

        :param async bool
        :param str path: (required)
        :param float p_limit: (required)
        :param str _1_property: (required)
        :param str _1_property_value: (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'p_limit', '_1_property', '_1_property_value']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_query" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `post_query`")
        # verify the required parameter 'p_limit' is set
        if ('p_limit' not in params) or (params['p_limit'] is None):
            raise ValueError("Missing the required parameter `p_limit` when calling `post_query`")
        # verify the required parameter '_1_property' is set
        if ('_1_property' not in params) or (params['_1_property'] is None):
            raise ValueError("Missing the required parameter `_1_property` when calling `post_query`")
        # verify the required parameter '_1_property_value' is set
        if ('_1_property_value' not in params) or (params['_1_property_value'] is None):
            raise ValueError("Missing the required parameter `_1_property_value` when calling `post_query`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))
        if 'p_limit' in params:
            query_params.append(('p.limit', params['p_limit']))
        if '_1_property' in params:
            query_params.append(('1_property', params['_1_property']))
        if '_1_property_value' in params:
            query_params.append(('1_property.value', params['_1_property_value']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/bin/querybuilder.json', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_tree_activation(self, ignoredeactivated, onlymodified, path, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_tree_activation(ignoredeactivated, onlymodified, path, async=True)
        >>> result = thread.get()

        :param async bool
        :param bool ignoredeactivated: (required)
        :param bool onlymodified: (required)
        :param str path: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_tree_activation_with_http_info(ignoredeactivated, onlymodified, path, **kwargs)
        else:
            (data) = self.post_tree_activation_with_http_info(ignoredeactivated, onlymodified, path, **kwargs)
            return data

    def post_tree_activation_with_http_info(self, ignoredeactivated, onlymodified, path, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_tree_activation_with_http_info(ignoredeactivated, onlymodified, path, async=True)
        >>> result = thread.get()

        :param async bool
        :param bool ignoredeactivated: (required)
        :param bool onlymodified: (required)
        :param str path: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ignoredeactivated', 'onlymodified', 'path']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_tree_activation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ignoredeactivated' is set
        if ('ignoredeactivated' not in params) or (params['ignoredeactivated'] is None):
            raise ValueError("Missing the required parameter `ignoredeactivated` when calling `post_tree_activation`")
        # verify the required parameter 'onlymodified' is set
        if ('onlymodified' not in params) or (params['onlymodified'] is None):
            raise ValueError("Missing the required parameter `onlymodified` when calling `post_tree_activation`")
        # verify the required parameter 'path' is set
        if ('path' not in params) or (params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `post_tree_activation`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ignoredeactivated' in params:
            query_params.append(('ignoredeactivated', params['ignoredeactivated']))
        if 'onlymodified' in params:
            query_params.append(('onlymodified', params['onlymodified']))
        if 'path' in params:
            query_params.append(('path', params['path']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/etc/replication/treeactivation.html', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_truststore(self, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_truststore(async=True)
        >>> result = thread.get()

        :param async bool
        :param str operation:
        :param str new_password:
        :param str re_password:
        :param str key_store_type:
        :param str remove_alias:
        :param file certificate:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_truststore_with_http_info(**kwargs)
        else:
            (data) = self.post_truststore_with_http_info(**kwargs)
            return data

    def post_truststore_with_http_info(self, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_truststore_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str operation:
        :param str new_password:
        :param str re_password:
        :param str key_store_type:
        :param str remove_alias:
        :param file certificate:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['operation', 'new_password', 're_password', 'key_store_type', 'remove_alias', 'certificate']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_truststore" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'operation' in params:
            query_params.append((':operation', params['operation']))
        if 'new_password' in params:
            query_params.append(('newPassword', params['new_password']))
        if 're_password' in params:
            query_params.append(('rePassword', params['re_password']))
        if 'key_store_type' in params:
            query_params.append(('keyStoreType', params['key_store_type']))
        if 'remove_alias' in params:
            query_params.append(('removeAlias', params['remove_alias']))

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'certificate' in params:
            local_var_files['certificate'] = params['certificate']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/libs/granite/security/post/truststore', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_truststore_pkcs12(self, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_truststore_pkcs12(async=True)
        >>> result = thread.get()

        :param async bool
        :param file truststore_p12:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_truststore_pkcs12_with_http_info(**kwargs)
        else:
            (data) = self.post_truststore_pkcs12_with_http_info(**kwargs)
            return data

    def post_truststore_pkcs12_with_http_info(self, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_truststore_pkcs12_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param file truststore_p12:
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['truststore_p12']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_truststore_pkcs12" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'truststore_p12' in params:
            local_var_files['truststore.p12'] = params['truststore_p12']

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['multipart/form-data'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/etc/truststore', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='str',
                                        auth_settings=auth_settings,
                                        async=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
